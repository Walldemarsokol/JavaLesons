//public class Main {
//    public static void main(String[] args) {
//        System.out.println("Hello world!");
//    }
//
//
//}

//    Вам даны две строки word1 и word2. Объедините строки, добавляя буквы
//        в чередующемся порядке, начиная со слова1. Если строка длиннее другой,
//        добавьте дополнительные буквы в конец объединенной строки.

//class Solution {
//    public String mergeAlternately(String word1, String word2) {
//        int i = 0;
//        String result = "";
//        while ((i < word1.length()) || (i < word2.length())) {
//
//            if (i < word1.length()) {
//                result = result + word1.charAt(i);
//            }
//            if (i < word2.length()) {
//                result = result + word2.charAt(i);
//            }
//            i++;
//        }
//        return result;
//    }
//}

//Учитывая целочисленный массив nums и целочисленное val, удалите все вхождения val в nums на месте.
//Относительный порядок элементов может быть изменен.
//
//Поскольку в некоторых языках невозможно изменить длину массива,
//вместо этого вы должны поместить результат в первую часть массива nums.
//Более формально, если есть k элементов после удаления дубликатов,
//то первые k элементов nums должны содержать окончательный результат.
//Неважно, что вы оставляете за первыми k элементами.
//
//Возвратите k после размещения окончательного результата в первых k слотах nums.
//Не выделяйте дополнительное пространство для другого массива. Вы должны сделать это,
//изменив входной массив на месте с дополнительной памятью O (1).

//class Solution {
//    public int removeElement(int[] nums, int val) {
//        int copyInd = 0;
//        for (int i = 0; i < nums.length; i++) {
//            if (nums[i] != val) {
//                nums[copyInd] = nums[i];
//                copyInd += 1;
//            }
//        }
//        return copyInd;
//    }
//}

//Вам даны два массива целых чисел nums1 и nums2,
//отсортированные в неубывающем порядке,
//и два целых числа m и n, представляющие количество элементов
//в nums1 и nums2 соответственно.
//Объедините nums1 и nums2 в один массив, отсортированный в неубывающем порядке.
//Окончательный отсортированный массив не должен возвращаться функцией,
//а должен храниться внутри массива nums1. Чтобы приспособиться к этому,
//nums1 имеет длину m + n, где первые m элементов обозначают элементы,
//которые должны быть объединены, а последние n элементов
//устанавливаются равными 0 и должны игнорироваться. nums2 имеет длину n.
//class Solution {
//    public void merge(int[] nums1, int m, int[] nums2, int n) {
//
//        while(m > 0 && n > 0){
//            if(nums1[m-1] > nums2[n-1]){
//                nums1[m+n-1] = nums1[m-1];
//                m--;
//            }else{
//                nums1[m+n-1] = nums2[n-1];
//                n--;
//            }
//        }
//
//        while(n > 0){
//            nums1[m+n-1] = nums2[n-1];
//            n--;
//        }
//    }
//}

//Учитывая входную строку s, измените порядок слов на противоположный.
//Слово определяется как последовательность не пробельных символов.
//Слова в s будут разделены хотя бы одним пробелом.
//Возвращает строку слов в обратном порядке, объединенных одним пробелом.
//Обратите внимание, что s может содержать начальные или конечные пробелы
//или несколько пробелов между двумя словами.
//Возвращаемая строка должна содержать только один пробел,
//разделяющий слова. Не включайте никаких дополнительных пробелов.

//class Solution {
//    public String reverseWords(String s) {
//        StringBuilder sb = new StringBuilder();
//        int end = s.length() - 1;
//        while (end >= 0) {
//            if (s.charAt(end) == ' ') {
//                end -= 1;
//                continue;
//            }
//
//            int start = end - 1;
//
//            while (start >= 0 && s.charAt(start) != ' ') {
//                start -= 1;
//            }
//            sb.append(" ");
//            sb.append(s.substring(start + 1, end + 1));
//            end = start - 1;
//        }
//        if (sb.length() > 0) {
//            sb.deleteCharAt(0);
//        }
//        return sb.toString();
//    }
//}

//
//Фраза является палиндромом, если после
//преобразования всех прописных букв в
//строчные и удаления всех не буквенно-цифровых
//символов она читается одинаково вперед и назад.
//Буквенно-цифровые символы включают буквы и цифры.
//
//Учитывая строку s, вернуть true, если это палиндром,
//или false в противном случае.
//class Solution {
//    public boolean isPalindrome(String s) {
//        int l = 0;
//        int r = s.length() - 1;
//
//        while (l < r) {
//            while (l < r && !Character.isLetterOrDigit(s.charAt(l)))
//                ++l;
//            while (l < r && !Character.isLetterOrDigit(s.charAt(r)))
//                --r;
//            if (Character.toLowerCase(s.charAt(l)) != Character.toLowerCase(s.charAt(r)))
//                return false;
//            ++l;
//            --r;
//        }
//
//        return true;
//    }
//}
